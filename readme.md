Созданы следующие функциональные интерфейсы:
- **Function1** — функция одного аргумента (**f(x)**);
- **Function2** — функция от двух аргументов (**f(x, y))**;
- **Predicate** — предикат для одного аргумента.

В рамках этих интерфейсов созданы методы:
- `Function1.compose` — композиция: принимает `Function1 g`, возвращает `g(f(x))`;
- `Function2.compose` — композиция: принимает `Function1 g`, возвращает `g(f(x, y))`;
- `Function2.bind1` — bind первого аргумента: принимает первый аргумент, возвращает `f(_, y)`;
- `Function2.bind2` — bind второго аргумента: принимает второй аргумент, возвращает `f(x, _)`;
- `Predicate.or/Predicate.and`: принимают один предикат в качестве аргумента, возвращают предикат, 
- Predicate.not принимает ноль аргументов, возвращает предикат-отрицание текущего предиката;
- Константные предикаты: `Predicate.ALWAYS_TRUE`, `Predicate.ALWAYS_FALSE`.

По аналогии со Stream API создана упрощённая реализация класса для работы с коллекциями с использованием созданных ранее функциональных интерфейсов **Function1**, **Function2** и **Predicate**.

Создан класс **Collections** со следующими статическими методами, оперирующими **Iterable**, **Function1**, **Function2** и **Predicate**:
- `map` — принимает `f` и `a`, применяет `f` к каждому элементу `a_i` и возвращает список `[f(a_1), ..., f(a_n)]`;
- `filter` — принимает `p` и `a`, возвращает список, содержащий элементы a_i, на которых `p(a_i) == true`;
- `takeWhile` — принимает `p` и `a`, возвращает список с началом a до первого элемента a_i, для которого `p(a_i) == false`;
- `takeUnless` — то же, что и `takeWhile`, только для `p(a_i) == true`;
- `foldr` / `foldl` — принимает функцию двух аргументов, начальное значение и коллекцию, работает так.

